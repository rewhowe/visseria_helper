function titleCase(s) {
  return s.split(/ |_/).map( (s) => s[0].toUpperCase() + s.slice(1) ).join(' ');
}

function studlyCase(s) {
  return s.split(/ |_/).map( (s) => s[0].toUpperCase() + s.slice(1) ).join('');
}

function int(i) {
  return parseInt(i) || 0;
}

$(function () {
  // don't show on pc
  if (window.matchMedia('only screen and (min-width: 640px)').matches) return;

  const $upButton = $('.js-up-button');
  const $downButton = $('.js-down-button');

  $(document).on('focus', 'input[type="number"]', function () {
    let rect = this.getBoundingClientRect();
    $upButton.removeClass('hidden')
      .css({
        top: rect.y + window.pageYOffset + 'px',
        left: rect.right + window.pageXOffset + 'px'
      });
    $downButton.removeClass('hidden')
      .css({
        top: rect.y + window.pageYOffset + 'px',
        left: rect.left - $downButton.outerWidth() + window.pageXOffset + 'px'
      });
  })
  .on('focusout', 'input[type="number"]', function () {
    $upButton.addClass('hidden');
    $downButton.addClass('hidden');
  });

  $upButton.on('mousedown', function (e) {
    const $focusedInput = $('input[type="number"]:focus');
    $focusedInput.val(int($focusedInput.val()) + 1).trigger('change');
    e.preventDefault();
  });

  $downButton.on('mousedown', function (e) {
    const $focusedInput = $('input[type="number"]:focus');
    $focusedInput.val(int($focusedInput.val()) - 1).trigger('change');
    e.preventDefault();
  });

  // respect min / max
  $(document).on('change', 'input[type="number"]', function () {
    let value = int($(this).val());
    if (this.max) value = Math.min(this.max, value);
    if (this.min) value = Math.max(this.min, value);
    $(this).val(value);
  });
});

const Select = {};

Select.KEY_DELIMITER = '.';

Select.makeKey = function (group, option) {
  return group + Select.KEY_DELIMITER + option;
};

Select.makeSelect = function (groupedOptions, className, required = true) {
  const $select = $('<select class="' + className + '">');

  $select.append('<option selected' + (required ? ' disabled' : '') + '>-</option>');

  for (let group in groupedOptions) {
    $optGroup = $('<optgroup label="' + titleCase(group) + '">');

    for (let option in groupedOptions[group]) {
      const key = group + Select.KEY_DELIMITER + option;
      const $option = $('<option value="' + key + '">' + titleCase(groupedOptions[group][option]) + '</option>');
      $optGroup.append($option);
    }

    $select.append($optGroup);
  }

  return $select;
};

// @require Select

const Gear = {};

Gear.GEAR = {
  basic_gear: {
    angel_feather: {
      cost: 3,
      dmg: 0,
      hp: 1,
      spec: 1,
      spec_type: 'soul',
    },
    ring_of_remnai: {
      cost: 3,
      dmg: 0,
      hp: 1,
      spec: 1,
      spec_type: 'intelligence',
    },
    badge_of_heroism: {
      cost: 3,
      dmg: 1,
      hp: 0,
      spec: 1,
      spec_type: 'courage',
    },
    blank_totem: {
      cost: 3,
      dmg: 0,
      hp: 1,
      spec: 1,
      spec_type: 'aura',
    },
    loaded_die: {
      cost: 3,
      dmg: 1,
      hp: 0,
      spec: 1,
      spec_type: 'luck',
    },
  },
  intermediate_gear: {
    exxo_armor: {
      cost: 5,
      dmg: 0,
      hp: 3,
      spec: 2,
      spec_type: 'soul',
    },
    trinity_staff: {
      cost: 5,
      dmg: 1,
      hp: 2,
      spec: 2,
      spec_type: 'intelligence',
    },
    darkling_sword: {
      cost: 5,
      dmg: 3,
      hp: 0,
      spec: 2,
      spec_type: 'courage',
    },
    illumination_pendant: {
      cost: 5,
      dmg: 0,
      hp: 3,
      spec: 2,
      spec_type: 'aura',
    },
    broken_dagger: {
      cost: 5,
      dmg: 2,
      hp: 1,
      spec: 2,
      spec_type: 'luck',
    },
  },
  standard_gear: {
    thirstfire: {
      cost: 5,
      dmg: 2,
      hp: 0,
      effect: 'Enemies the equipped User attacks are debuffed with Bleed',
    },
    mugger_dagger: {
      cost: 5,
      dmg: 2,
      hp: 0,
      effect: 'Equipped User gains 1G for every successful attack on an Enemy if Success roll',
    },
    bones: {
      cost: 5,
      dmg: 1,
      hp: 5,
      effect: 'While equipped with Bones: equipped User is debuffed with Undead', // TODO
    },
    lucky_charm: {
      cost: 5,
      dmg: 1,
      hp: 1,
      effect: 'Equipped User gains +2 Success roll',
    },
    devil_charm: {
      cost: 5,
      dmg: 3,
      hp: 3,
      effect: 'Equipped User gains -2 Success roll',
    },
    courage_charm: {
      cost: 5,
      dmg: 2,
      hp: 1,
      effect: 'Equipped User gains +1 Decisive roll in battle involving User',
    },
    artifact_coin: {
      cost: 5,
      dmg: 2,
      hp: 2,
      effect: 'Item is treated as 5G',
    },
    absorbing_spirit: {
      cost: 5,
      dmg: 2,
      hp: 2,
      effect: 'Equipped User\'s Ultimate recharge rate is 2',
    },
    regenerating_armour: {
      cost: 5,
      dmg: 0,
      hp: 3,
      effect: 'Any DMG the equipped User receives from any source is reduced by 1 DMG',
    },
    the_murmur: {
      cost: 5,
      dmg: 5,
      hp: 0,
      effect: 'While equipped with The Murmur: equipped User is debuffed with Silence', // TODO
    },
  },
  legendary_gear: {
    'wilhelm\'s_gauntlet': {
      cost: 15,
      dmg: 0,
      hp: 5,
      limit_class: 'guardian',
      effect: 'When the equipped User is attacked: deal DMG equal to the equipped User\'s DMG to the attacking Enemy. Can only be equipped by Guardians',
      spec: 3,
      spec_type: 'soul',
    },
    'solomon\'s_cipher': {
      cost: 15,
      dmg: 2,
      hp: 3,
      limit_class: 'spellweaver',
      effect: 'The equipped User can attack and use abilities once each before becoming inactive. Can only be equipped by Spellweavers',
      spec: 3,
      spec_type: 'intelligence',
    },
    'zatyr\'s_saber': {
      cost: 15,
      dmg: 5,
      hp: 0,
      limit_class: 'slayer',
      effect: 'When the equipped User attacks: equipped User recovers (Room Lvl) HP. Can only be equipped by Slayers',
      spec: 3,
      spec_type: 'courage',
    },
    'magus\'_cloak': {
      cost: 15,
      dmg: 1,
      hp: 4,
      limit_class: 'enchanter',
      effect: 'Remove all debuffs from the equipped User. Equipped User is immune to debuffs. Can only be equipped by Enchanters', // TODO
      spec: 3,
      spec_type: 'aura',
    },
    'weeper\'s_satchel': {
      cost: 15,
      dmg: 3,
      hp: 2,
      limit_class: 'trickster',
      effect: 'When this item is acquired: acquire 1 Item and +XG equal to D10 roll. The equipped User gains +2 Success roll. Can only be equipped by Tricksters',
      spec: 3,
      spec_type: 'luck',
    }
  },
};

Gear.getGear = function (key) {
  key = key.split(Select.KEY_DELIMITER);
  const category = Gear.GEAR[key[0]];
  if (!category) return;
  const gear = category[key[1]];
  gear.category = key[0];
  gear.name = key[1];
  return gear;
}

Gear.getGearKey = function (gear) {
  return Select.makeKey(gear.category, gear.name);
}

Gear.$GEAR_SELECT = (function () {
  const options = {};

  for (let categoryName in Gear.GEAR) {
    options[categoryName] = {};

    for (let gearName in Gear.GEAR[categoryName]) {
      const gear = Gear.GEAR[categoryName][gearName];
      const stats = [
        gear.dmg || 0,
        gear.hp || 0,
        gear.spec ? gear.spec + ' ' + gear.spec_type : 0,
      ];
      options[categoryName][gearName] = gearName
        + ' (' + stats.join('/') + ')'
        + (gear.limit_class ? ' - ' + titleCase(gear.limit_class) + ' only' : '');
    }
  }

  return Select.makeSelect(options, 'js-gear-select', false);
})();

// @require Select

const Classes = {};

Classes.CLASSES = {
  guardian: {
    spec_type: 'soul',
    characters: {
      albatross_grand: {
        title: 'The Armored Angel',
        dmg: 2,
        hp: 18,
        abilities: {
          passive: {
            name: 'Endure',
            effect: 'Any DMG Albatross Grand receives is reduced by (Room Lvl). When Albatross Grand activates an Ultimate ability: this ability is negated',
          },
          active: {
            name: 'Divine Intervention',
            effect: 'When an ally User is attacked: Albatross Grand is attacked instead',
          },
          ultimate: {
            name: 'Beckoning Light',
            effect: 'Enemies can only attack Albatross Grand. Any DMG Albatross Grand receives is reduced by (Soul Lvl) DMG. This ability lasts until Albatross Grand becomes active',
            recharge: 7,
          },
        },
      },
      T4O_MKII: {
        title: 'The Soul in the Shell',
        dmg: 3,
        hp: 17,
        abilities: {
          passive: {
            name: 'Welded Will',
            effect: 'T4O MKII cannot be debuffed with Bleed or Fear. T4O MKII gains (Soul Lvl) Max HP',
          },
          active: {
            name: 'Self Destruct',
            effect: 'T4O MKII deals X DMG to 1 Enemy and loses X HP (X cannot be greater than T4O MKII\'s current HP)',
          },
          ultimate: {
            name: 'Recharge',
            effect: 'T4O MKII Recovers to Max HP',
            recharge: 7,
          },
        },
      },
      lilith: {
        title: 'The Bad Blood',
        dmg: 1,
        hp: 16,
        abilities: {
          passive: {
            name: 'Tear',
            effect: 'When Lilith attacks an Enemy: the attacked Enemy is debuffed with Bleed',
          },
          active: {
            name: 'Blood Drain',
            effect: 'If an active Enemy is debuffed with Bleed, remove the debuff: deal (Soul Lvl) DMG to that Enemy. Lilith Recovers (Soul Lvl) HP',
          },
          ultimate: {
            name: 'Vampirism',
            effect: 'All enemies are now debuffed with Bleed',
            recharge: 6,
          },
        },
      },
    },
  },
  spellweaver: {
    spec_type: 'intelligence',
    characters: {
      harmony_marx: {
        title: 'The Sorcerer Songstress',
        dmg: 4,
        hp: 14,
        abilities: {
          passive: {
            name: 'Tempo',
            effect: 'When Harmony Marx attacks an enemy: Harmony Marx gains + (Intelligence Lvl) Success roll. This effect stacks but resets when Harmony Marx leaves the current Room, Dies or uses an ability',
          },
          active: {
            name: 'Song of Silence',
            effect: 'Success roll: debuff (Intelligence Lvl) Enemies with Silence until Harmony Marx becomes active',
          },
          ultimate: {
            name: 'Da Capo',
            effect: 'Success roll: all inactive Users become active',
            recharge: 10,
          },
        },
      },
      ariadne: {
        title: 'The Blind Prophet',
        dmg: 5,
        hp: 11,
        abilities: {
          passive: {
            name: 'Dimensional Decision',
            effect: 'Once during your turn when a Room Tile is revealed: reveal the top 3 Room Cards of that revealed Room Tile from the respective deck and choose 1. The revealed Room Tile is now that chosen Room Card. Shuffle the other Room Cards revealed this way back into their respective decks',
          },
          active: {
            name: 'Darkness Falls',
            effect: 'Success roll: debuff (Intelligence Lvl) Enemies with Blind until Ariadne becomes active',
          },
          ultimate: {
            name: 'Foreseer\'s Favour',
            effect: "Ariadne gains the following ability based on the current Room type:\nMob/Boss Room - Once per Room: Ariadne gains (Intelligence Lvl) DMG for the Room\nTrap Room - Ariadne gains + (Intelligence Lvl) Success roll\nTreasure Room - Acquire 1 Item if an Item is acquired",
            recharge: 5,
          },
        },
      },
      psykoshka: {
        title: 'The Lost Familiar',
        dmg: 4,
        hp: 13,
        abilities: {
          passive: {
            name: 'Symmetry',
            effect: 'Psykoshka gains (Intelligence Lvl) DMG',
          },
          active: {
            name: 'Copycat',
            effect: 'Psykoshka can use the active ability of 1 ally User and gains that User\'s Special Stat and Special Stat Lvl until Psykoshka becomes active',
          },
          ultimate: {
            name: 'Loyalty',
            effect: 'Ally Users gain (Intelligence Lvl) Special Stat Lvl until Psykoshka becomes active',
            recharge: 8,
          },
        },
      },
    },
  },
  slayer: {
    spec_type: 'courage',
    characters: {
      grimwulf_kaiser: {
        title: 'The Howling Death',
        dmg: 9,
        hp: 9,
        abilities: {
          passive: {
            name: 'Battle Howl',
            effect: 'Gain + (Courage Lvl) Decisive roll',
          },
          active: {
            name: 'Duality',
            effect: 'Deal half of DMG + (Courage Lvl) (rounded up) to 2 different Enemies ',
          },
          ultimate: {
            name: 'Hellhound',
            effect: 'Spawn a Hellhound Token with (Courage Lvl) DMG and (Courage Lvl) Max HP. Hellhound Token is treated as an ally User (cannot acquire or hold Gear). There can only be 1 Hellhound Token at a time',
            recharge: 5,
          },
        },
      },
      jackal: {
        title: 'The Soundslinger',
        dmg: 7,
        hp: 7,
        abilities: {
          passive: {
            name: 'Sonic Snipe',
            effect: 'During Battle before Decisive roll, Success roll: Jackal can immediately attack 1 Enemy',
          },
          active: {
            name: 'Distortion',
            effect: 'Deal (Courage Lvl) DMG to all Enemies with debuffs',
          },
          ultimate: {
            name: 'EQ',
            effect: 'Target 1 User and 1 Basic Enemy: Halve the sum of those targets\' current HP (rounded up). The targeted User and Basic Enemy\'s HP become the result',
            recharge: 7,
          },
        },
      },
      vulcana: {
        title: 'The Pyroxian Flame',
        dmg: 8,
        hp: 8,
        abilities: {
          passive: {
            name: 'Overheat',
            effect: 'When Vulcana defeats an Enemy: deal any overkill DMG to another Enemy',
          },
          active: {
            name: 'Fever',
            effect: 'Vulcana gains (Courage Lvl) DMG for the next attack',
          },
          ultimate: {
            name: 'Pyreball',
            effect: 'Success roll: Vulcana deals DMG + (Courage Lvl) to 1 Enemy. This ability repeats 3 times',
            recharge: 6,
          },
        },
      },
    },
  },
  enchanter: {
    spec_type: 'aura',
    characters: {
      misteyes_snow: {
        title: 'The White Fox',
        dmg: 3,
        hp: 14,
        abilities: {
          passive: {
            name: 'Empath',
            effect: 'When Misteyes Snow Recovers HP: Recover 1 ally User for the same amount + (Aura Lvl) HP',
          },
          active: {
            name: 'Erasure',
            effect: 'Remove all debuffs on (Aura Lvl) ally Users',
          },
          ultimate: {
            name: 'Light of Life',
            effect: 'If an ally User is Dead: Resurrect the Dead User',
            recharge: 10,
          },
        },
      },
      dexler: {
        title: 'The Mad Alchemist',
        dmg: 1,
        hp: 11,
        abilities: {
          passive: {
            name: 'Duplicate',
            effect: 'When a Consumable Item would be discarded, Success roll: the Consumable Item is not discarded',
          },
          active: {
            name: 'Alchemic Warfare',
            effect: 'Discard 1 Consumable Item: deal 5 + (Aura Lvl) DMG to 1 Enemy or 1 ally User Recovers 5 + (Aura Lvl) HP',
          },
          ultimate: {
            name: 'The Creator',
            effect: 'Search for 1 Consumable Item in the Item deck and acquire it',
            recharge: 7,
          },
        },
      },
      faerie: {
        title: 'The Fable of the Forest',
        dmg: 0,
        hp: 13,
        abilities: {
          passive: {
            name: 'Blessing of the Fae',
            effect: 'While Faerie is at Max HP: Faerie and ally Users gain + 1 Success roll and (Room Lvl) DMG',
          },
          active: {
            name: 'Sacred Medicine',
            effect: '1 User Recovers (Aura Lvl) HP',
          },
          ultimate: {
            name: 'Faeth',
            effect: '1 active User Recovers to Max HP and loses all debuffs. That User becomes inactive',
            recharge: 7,
          },
        },
      },
    },
  },
  trickster: {
    spec_type: 'luck',
    characters: {
      ein: {
        title: 'The Shadewalker',
        dmg: 5,
        hp: 10,
        abilities: {
          passive: {
            name: 'Get Chance and Luck',
            effect: 'When Ein or an ally User pass a Success roll: Ein gains (Luck Lvl) DMG. This effect can stack but resets if Ein leaves the current Room, Dies or if a Success roll fails',
          },
          active: {
            name: 'Gamble',
            effect: 'Ally Users gain + (Luck Lvl) Success roll. This ability can be used in a Trap Room and lasts until Ein becomes active',
          },
          ultimate: {
            name: 'Shadow Sneak',
            effect: 'Upon discovering a Trap Room, Success roll: that discovered Trap Room is disabled',
            recharge: 7,
          },
        },
      },
      zuciel: {
        title: 'The Phantom of Sin',
        dmg: 0,
        hp: 13,
        abilities: {
          passive: {
            name: 'Greed',
            effect: 'Zuciel cannot gain DMG from any Gear but gains DMG equal to the Party’s total G. Zuciel\'s Party can buy Items for 1 less G. This ability cannot be negated by Silence',
          },
          active: {
            name: 'Sloth',
            effect: 'Zuciel Recovers (Luck Lvl) HP',
          },
          ultimate: {
            name: 'Wrath',
            effect: 'If all ally Users are active: Zuciel can attack (Luck Lvl) Enemies once each. All ally Users become inactive',
            recharge: 5,
          },
        },
      },
      marina: {
        title: 'The Chronokeeper',
        dmg: 5,
        hp: 10,
        abilities: {
          passive: {
            name: 'Choice of Chronos',
            effect: 'When an Item is acquired: Marina can discard the Item and acquire a new one instead. This can be repeated (Luck Lvl) times',
          },
          active: {
            name: 'Rewrite Destiny',
            effect: 'Whenever a die is rolled: Marina can ignore the result and roll once more',
          },
          ultimate: {
            name: 'Gift of the Chronokeepers',
            effect: 'Once per Room: all ally Users’ Ultimate Gauge recharge by (Luck Lvl) ',
            recharge: 10,
          },
        },
      },
    },
  },
};

Classes.getCharacterData = function (key) {
  key = key.split(Select.KEY_DELIMITER);
  const character = Classes.CLASSES[key[0]].characters[key[1]];
  character.class = key[0];
  character.name = key[1];
  character.specType = Classes.CLASSES[key[0]].spec_type;
  return character;
}

Classes.getCharacterKey = function (character) {
  return Select.makeKey(character.class, character.name);
}

Classes.makeCharacter = function ($node, characterKey, bundle = null) {
  const characterClassName = studlyCase(characterKey.split(Select.KEY_DELIMITER)[1]);

  // if (typeof characterClassName === 'undefined') {
  //   return new Character($node, characterKey, bundle);
  // }
  console.log(characterKey);
  return new Classes[characterClassName]($node, characterKey, bundle);
  // return new Function('new ' + characterClassName)($node, characterKey, bundle);
}

Classes.$CLASS_SELECT = (function () {
  const options = {};

  for (let className in Classes.CLASSES) {
    options[className] = {};
    for (let character in Classes.CLASSES[className].characters) {
      options[className][character] = character;
    }
  }

  return Select.makeSelect(options, 'js-class-select');
})();

// @require Classes, Gear

class Character {

  static get MAX_LEVEL() { return 3; }
  static get LEVEL_BONUS() { return 2; }

  constructor($node, characterKey, bundle = null) {
    this.$node = $node;

    console.log(characterKey);
    const character = Classes.getCharacterData(characterKey);
    this.class = character.class;
    this.name = character.name;
    this.specType = character.specType;
    this.abilities = character.abilities;

    this.$node.removeClass(Object.keys(Classes.CLASSES).join(' '))
      .addClass(this.class);

    // this.$class = Classes.$CLASS_SELECT.clone();
    // this.$node.find('.js-class').append(this.$class);

    // this.character = null;
    this.level = 0;
    // this.ready = false;

    this.$icon = this.$node.find('.js-icon')
      .attr('src', './public/img/' + this.name.toLowerCase() + '.png');
    this.$title = this.$node.find('.js-title')
      .html(character.title);

    this.$debuffs = this.$node.find('.js-debuff input[type="checkbox"]');
    for (let debuff of this.$debuffs) {
      $(debuff).prop('checked', false).parent().removeClass('checked');
    }

    this.$ultimate = this.$node.find('.js-ability-ultimate');
    this.setAbilities();

    this.hp = {
      current: character.hp,
      base: character.hp,
      $current: this.$node.find('.js-hp-current').val(character.hp),
      $value: this.$node.find('.js-hp-max'),
      $detail: this.$node.find('.js-hp-detail'),
      $mod: this.$node.find('.js-hp-mod'),
    };

    this.dmg = {
      base: character.dmg,
      $value: this.$node.find('.js-dmg-value').val(character.dmg),
      $detail: this.$node.find('.js-dmg-detail'),
      $mod: this.$node.find('.js-dmg-mod'),
    };

    this.spec = {
      base: 1,
      $name: this.$node.find('.js-spec-name').html(titleCase(character.specType)),
      $value: this.$node.find('.js-spec-value'),
      $detail: this.$node.find('.js-spec-detail'),
      $mod: this.$node.find('.js-spec-mod'),
    };

    this.recharge = {
      current: 0,
      base: character.abilities.ultimate.recharge,
      $current: this.$node.find('.js-recharge-current').val(0),
      $value: this.$node.find('.js-recharge-value'),
      $detail: this.$node.find('.js-recharge-detail'),
      $mod: this.$node.find('.js-recharge-mod'),
    };

    this.gear = [];
    this.$gear = this.$node.find('.js-gear');
    this.$gear.find('.js-gear-select').val('-');
    this.$node.find('.js-gear-show-detail, .js-gear-detail')
      .addClass('hidden')
      .removeClass('pressed');

    this.$node.find('.js-status-mod').val('');

    if (bundle) this.fromBundle(bundle);

    for (let status of ['hp', 'dmg', 'spec', 'recharge']) this.mod(status);

    this.$node.find('.js-character-detail').slideDown();
  }

  // changeClass(characterKey) {
    // this.ready = true;
    // this.character = Classes.getCharacterData(characterKey);

    // this.$node.removeClass(Object.keys(Classes.CLASSES).join(' ')).addClass(this.class);
    // this.$icon.attr('src', './public/img/' + this.character.name.toLowerCase() + '.png');
    // this.$title.html(this.character.title);
    // this.gear = [];
    // this.$gear.find('.js-gear-select').val('-');
    // this.setAbilities();

    // this.$node.find('.js-gear-show-detail, .js-gear-detail')
    //   .addClass('hidden')
    //   .removeClass('pressed');

    // for (let debuff of this.$debuffs) {
    //   $(debuff).prop('checked', false).parent().removeClass('checked');
    // }

    // this.$node.find('.js-status-mod').val('');

    // this.hp.current = this.character.hp;
    // this.hp.base = this.character.hp;
    // this.hp.$current.val(this.character.hp);
    // this.mod('hp');

    // this.dmg.base = this.character.dmg;
    // this.mod('dmg');

    // this.spec.base = 1;
    // this.spec.$name.html(titleCase(this.character.specType));
    // this.mod('spec');

    // this.recharge.current = 0;
    // this.recharge.base = this.character.abilities.ultimate.recharge;
    // this.hp.$current.val(0);
    // this.mod('recharge');

    // this.$node.find('.js-character-detail').slideDown();
  // }

  mod(status) {
    const mod = this.getStatusMod(status);
    const value = this[status].base + this.getLevelMod(status);

    const moddedValue = Math.max(0, value + mod);

    this[status].$value.html(moddedValue);

    if (mod !== 0) {
      const operator = mod > 0 ? ' + ' : ' - ';
      this[status].$detail.html(value + operator + Math.abs(mod));
      this[status].$detail.parent().addClass('character-status-modified');
    } else {
      this[status].$detail.html('');
      this[status].$detail.parent().removeClass('character-status-modified');
    }

    if (['hp', 'recharge'].indexOf(status) !== -1) {
      this[status].current = Math.min(this[status].current, moddedValue);
      this[status].$current.val(this[status].current);

      if (status === 'recharge') {
        if (this.recharge.current === moddedValue) {
          this.$ultimate.addClass('charged');
        } else {
          this.$ultimate.removeClass('charged');
        }
      }
    }
  }

  setAbilities() {
    // for (let abilityType in this.character.abilities) {
    for (let abilityType in this.abilities) {
      const ability = this.abilities[abilityType];
      this.$node.find('.js-ability-' + abilityType + ' .js-ability-name').html(ability.name);
      this.$node.find('.js-ability-' + abilityType + ' .js-ability-detail').html(ability.effect);
    }
  }

  getLevelMod(status) {
    if (['hp', 'dmg'].indexOf(status) === -1) return 0
    // if (this.character.name == 'zuciel' && status == 'dmg') return 0;
    if (this.name == 'zuciel' && status == 'dmg') return 0;
    return this.level * Character.LEVEL_BONUS;
  }

  getStatusMod(status) {
    return int(this[status].$mod.val())
      + this.getGearMod(status);
      // + this.getCharacterMod(status);
  }

  getGearMod(status) {
    const character = this.character;

    return this.gear.reduce(function (carry, gear) {
      // if (gear && (status !== 'spec' || !gear.spec_type || gear.spec_type === character.specType)) {
      if (gear && (status !== 'spec' || !gear.spec_type || gear.spec_type === this.specType)) {
        carry += gear[status] || 0;
      }
      return carry;
    }, 0);
  }

  // TODO: if this starts getting unwieldy, convert to using child classes
  // getCharacterMod(status) {
  //   switch (this.character.name) {
  //     case 'zuciel':
  //       this.$gold = this.$gold || $('.js-gold');
  //       const gold = int(this.$gold.val());
  //       return status == 'dmg' ? gold - this.getGearMod(status) : 0;
  //     case 'psykoshka':
  //       if (status !== 'dmg') return 0;
  //       return this.spec.base + this.getStatusMod('spec');
  //     default:
  //       return 0;
  //   }
  // }

  updateCurrent(status) {
    this[status].current = int(this[status].$current.val());

    // tickle
    this.mod(status);

    if (status === 'hp' && this.hp.current === 0) {
      this.$node.addClass('dead');
    } else {
      this.$node.removeClass('dead');
    }
  }

  updateGear(slot, gearKey) {
    const gear = Gear.getGear(gearKey);

    // const canWear = gear && (!gear.limit_class || this.character.class === gear.limit_class);
    const canWear = gear && (!gear.limit_class || this.class === gear.limit_class);
    this.gear[slot] = canWear ? gear : undefined;

    this.mod('hp');
    this.mod('dmg');
    this.mod('spec');
    this.mod('recharge');

    this.updateGearEffect(this.gear[slot], $(this.$gear[slot]));

    return canWear;
  }

  updateGearEffect(gear, $gear) {
    if (gear && gear.effect) {
      $gear.find('.js-gear-show-detail').removeClass('hidden');
      $gear.find('.js-gear-detail').html(gear.effect);
    } else {
      $gear.find('.js-gear-show-detail, .js-gear-detail').addClass('hidden');
      $gear.find('.js-gear-detail').html('');
    }
  }

  updateLevel(level) {
    this.level = Math.min(Character.MAX_LEVEL, Math.max(0, level));
    this.mod('hp');
    this.mod('dmg');

    // full heal
    this.hp.$current.val(this.hp.base + this.getLevelMod('hp') + this.getStatusMod('hp'));
    this.updateCurrent('hp');
  }

  // serializer

  toBundle() {
    const bundle = {
      debuffs: this.$debuffs.map((i, checkbox) => checkbox.checked).toArray(),
      // TODO: fix
      character_key: Classes.getCharacterKey(this.character),
      level: this.level,
      hp: {
        current: this.hp.current,
        mod: int(this.hp.$mod.val())
      },
      dmg: { mod: int(this.dmg.$mod.val()) },
      spec: { mod: int(this.spec.$mod.val()) },
      recharge: {
        current: this.recharge.current,
        mod: int(this.recharge.$mod.val())
      },
      gear: [],
    };

    for (let gear of this.gear) {
      if (gear) bundle.gear.push(Gear.getGearKey(gear));
    }

    return bundle;
  }

  fromBundle(bundle) {
    this.$class.val(bundle.character_key);
    this.level = bundle.level;

    for (let slot in bundle.gear) {
      this.gear[slot] = Gear.getGear(bundle.gear[slot]);
      $(this.$gear[slot]).find('.js-gear-select').val(bundle.gear[slot]);
      this.updateGearEffect(this.gear[slot], $(this.$gear[slot]));
    }

    for (let status of ['hp', 'dmg', 'spec', 'recharge']) {
      this[status].$mod.val(int(bundle[status].mod));
      if (['hp', 'recharge'].indexOf(status) !== -1) this[status].current = bundle[status].current;
      // this.mod(status);
    }

    for (let i in bundle.debuffs) {
      if (!bundle.debuffs[i]) continue;
      $(this.$debuffs[i]).prop('checked', true).parent().toggleClass('checked');
    }
  }
};

Classes.AlbatrossGrand = class AlbatrossGrand extends Character {
  constructor($node, characterKey, bundle) {
    console.log('calling parent');
    console.log($node);
    super($node, characterKey, bundle);
    console.log('hi im albatross');
  }
};

// @require Gear, Classes, Character

// TODO: code
// * update with latest doc

$(function () {
  const APP_VERSION = 'v1'; // not backwards compatible
  $('.js-version').html(APP_VERSION);

  const MAX_CHARACTERS = 5;
  const SAVE_DELAY = 5000;

  const PROMPT = {
    REQUEST: {
      MESSAGE: 'Would you like to save your data locally?',
      NO: 'No, don\'t!',
      YES: 'Sure',
    },
    UPDATE: {
      MESSAGE: 'Hey, we\'ve updated, so old data will be deleted. Sorry!<br>'
        + 'Do you still want to save your data locally?',
      NO: 'Nah',
      YES: 'Yes please!',
    },
  };

  const $storagePrompt = $('.js-storage-prompt');
  const $template = $('.js-character-template .js-character');
  const $keyShards = $('.js-key-shards');
  const $gold = $('.js-gold');
  const $mainContent = $('.js-main-content');
  const $addButton = $('.js-add-character');

  let storage = null;
  let savePid = null;

  $template.find('.js-class').append(Classes.$CLASS_SELECT.clone());
  $template.find('.js-gear').each((i, gear) => $(gear).prepend(Gear.$GEAR_SELECT.clone().data('slot', i)));

  function addCharacter(bundle = null) {
    // const $character = $template.clone();
    // $character.data('character', new Character($character, bundle));
    // $character.insertBefore($addButton.parent());
    $template.clone().insertBefore($addButton.parent());

    if (bundle) {
      // TODO: do same as change class but pass bundle
    }
  }

  function checkCharacterLimit() {
    $mainContent.find('.js-character').length >= MAX_CHARACTERS ? $addButton.hide() : $addButton.show();
  }

  function queueSave() {
    window.clearTimeout(savePid);
    savePid = window.setTimeout(saveToStorage, SAVE_DELAY);
  }

  function saveToStorage() {
    storage[APP_VERSION] = {
      key_shards: int($keyShards.val()),
      gold: int($gold.val()),
      characters: [],
    };

    $mainContent.find('.js-character').each(function (i, characterSheet) {
      const character = $(characterSheet).data('character');
      // TODO: remove all ready stuff
      if (!character.ready) return;
      storage[APP_VERSION].characters.push(character.toBundle());
    });

    localStorage.visseria = JSON.stringify(storage);
  }

  $addButton.on('click', function () {
    addCharacter();
    checkCharacterLimit();
  });

  $storagePrompt.on('click', '.js-prompt-button', function () {
    if ($(this).data('answer') === 'yes') {
      storage = {};
      saveToStorage();
    }
    $storagePrompt.remove();
  })

  $(document).on('change', queueSave);

  $keyShards.on('change', function () {
    const level = int($(this).val());
    $('.js-character').each(function (i, el) {
      const character = $(el).data('character');
      if (!character || !character.ready) return;
      character.updateLevel(level);
    });
  });

  $(document).on('click', '.js-delete-character', function () {
    $(this).closest('.js-character').remove();
    checkCharacterLimit();
    queueSave();
  });

  $(document).on('change', '.js-class-select', function () {
    const $character = $(this).closest('.js-character');
    // const character = $character.data('character');
    // character.changeClass($(this).val());
    const character = Classes.makeCharacter($character, $(this).val());
    $character.data('character', character);

    $keyShards.trigger('change');
  });

  $(document).on('change', '.js-gear-select', function () {
    const character = $(this).closest('.js-character').data('character');
    if (!character.ready) return;
    const canWear = character.updateGear($(this).data('slot'), $(this).val());

    if (!canWear) $(this).val('-');
  });

  $(document).on('change', '.js-status-mod', function () {
    const character = $(this).closest('.js-character').data('character');
    if (!character.ready) return;
    character.mod($(this).data('status'));
  });

  $(document).on('change', '.js-hp-current, .js-recharge-current', function () {
    const character = $(this).closest('.js-character').data('character');
    if (!character.ready) return;
    character.updateCurrent($(this).data('status'));
  });

  for (let type of ['gear', 'ability']) {
    $(document).on('click', '.js-' + type + '-show-detail', function () {
      $(this).toggleClass('pressed');
      const $detail = $(this).parent().siblings('.js-' + type + '-detail');
      $detail.toggleClass('hidden');
    });
  }

  $(document).on('click', '.js-debuff input[type="checkbox"]', function () {
    $(this).parent().toggleClass('checked');
  });

  if (localStorage.visseria) {
    try {
      storage = JSON.parse(localStorage.visseria);

      if (Object.keys(storage).length > 0 && !storage[APP_VERSION]) {
        $storagePrompt.find('.js-prompt-message').html(PROMPT.UPDATE.MESSAGE);
        $storagePrompt.find('.js-prompt-button.no').html(PROMPT.UPDATE.NO);
        $storagePrompt.find('.js-prompt-button.yes').html(PROMPT.UPDATE.YES);
        $storagePrompt.removeClass('hidden');
        throw 'App was updated to version: ' + APP_VERSION;
      }

      $keyShards.val(storage[APP_VERSION].key_shards);
      $gold.val(storage[APP_VERSION].gold);

      if (storage[APP_VERSION].characters) {
        for (let bundle of storage[APP_VERSION].characters) {
          addCharacter(bundle);
        }
      }
    } catch (e) {
      console.error("An error occurred while loading from storage:\n" + e);
      storage = {};
    }
  } else {
    $storagePrompt.find('.js-prompt-message').html(PROMPT.REQUEST.MESSAGE);
    $storagePrompt.find('.js-prompt-button.no').html(PROMPT.REQUEST.NO);
    $storagePrompt.find('.js-prompt-button.yes').html(PROMPT.REQUEST.YES);
    $storagePrompt.removeClass('hidden');
  }

  if ($mainContent.find('.js-character').length === 0) {
    addCharacter();
  }
});
